// Generated by gencpp from file cubot/cubot_msg.msg
// DO NOT EDIT!


#ifndef CUBOT_MESSAGE_CUBOT_MSG_H
#define CUBOT_MESSAGE_CUBOT_MSG_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace cubot
{
template <class ContainerAllocator>
struct cubot_msg_
{
  typedef cubot_msg_<ContainerAllocator> Type;

  cubot_msg_()
    : IMUyaw(0.0)
    , wheelspeed0(0)
    , wheelspeed1(0)
    , wheelspeed2(0)
    , wheelspeed3(0)
    , stm32clock(0)
    , gyrox(0)
    , gyroy(0)
    , gyroz(0)
    , accx(0)
    , accy(0)
    , accz(0)
    , qyaw(0.0)
    , qpitch(0.0)
    , qroll(0.0)  {
    }
  cubot_msg_(const ContainerAllocator& _alloc)
    : IMUyaw(0.0)
    , wheelspeed0(0)
    , wheelspeed1(0)
    , wheelspeed2(0)
    , wheelspeed3(0)
    , stm32clock(0)
    , gyrox(0)
    , gyroy(0)
    , gyroz(0)
    , accx(0)
    , accy(0)
    , accz(0)
    , qyaw(0.0)
    , qpitch(0.0)
    , qroll(0.0)  {
  (void)_alloc;
    }



   typedef float _IMUyaw_type;
  _IMUyaw_type IMUyaw;

   typedef int16_t _wheelspeed0_type;
  _wheelspeed0_type wheelspeed0;

   typedef int16_t _wheelspeed1_type;
  _wheelspeed1_type wheelspeed1;

   typedef int16_t _wheelspeed2_type;
  _wheelspeed2_type wheelspeed2;

   typedef int16_t _wheelspeed3_type;
  _wheelspeed3_type wheelspeed3;

   typedef uint32_t _stm32clock_type;
  _stm32clock_type stm32clock;

   typedef int16_t _gyrox_type;
  _gyrox_type gyrox;

   typedef int16_t _gyroy_type;
  _gyroy_type gyroy;

   typedef int16_t _gyroz_type;
  _gyroz_type gyroz;

   typedef int16_t _accx_type;
  _accx_type accx;

   typedef int16_t _accy_type;
  _accy_type accy;

   typedef int16_t _accz_type;
  _accz_type accz;

   typedef float _qyaw_type;
  _qyaw_type qyaw;

   typedef float _qpitch_type;
  _qpitch_type qpitch;

   typedef float _qroll_type;
  _qroll_type qroll;





  typedef boost::shared_ptr< ::cubot::cubot_msg_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::cubot::cubot_msg_<ContainerAllocator> const> ConstPtr;

}; // struct cubot_msg_

typedef ::cubot::cubot_msg_<std::allocator<void> > cubot_msg;

typedef boost::shared_ptr< ::cubot::cubot_msg > cubot_msgPtr;
typedef boost::shared_ptr< ::cubot::cubot_msg const> cubot_msgConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::cubot::cubot_msg_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::cubot::cubot_msg_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace cubot

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': True, 'IsMessage': True, 'HasHeader': False}
// {'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg'], 'cubot': ['/home/ethan/nav_ws/src/cubot/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::cubot::cubot_msg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::cubot::cubot_msg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::cubot::cubot_msg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::cubot::cubot_msg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::cubot::cubot_msg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::cubot::cubot_msg_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::cubot::cubot_msg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "a1fc69e1ab3f3f95a2a373d704866612";
  }

  static const char* value(const ::cubot::cubot_msg_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xa1fc69e1ab3f3f95ULL;
  static const uint64_t static_value2 = 0xa2a373d704866612ULL;
};

template<class ContainerAllocator>
struct DataType< ::cubot::cubot_msg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "cubot/cubot_msg";
  }

  static const char* value(const ::cubot::cubot_msg_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::cubot::cubot_msg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float32 IMUyaw\n\
int16 wheelspeed0\n\
int16 wheelspeed1\n\
int16 wheelspeed2\n\
int16 wheelspeed3\n\
uint32 stm32clock\n\
int16 gyrox\n\
int16 gyroy\n\
int16 gyroz\n\
int16 accx\n\
int16 accy\n\
int16 accz\n\
float32 qyaw\n\
float32 qpitch\n\
float32 qroll\n\
";
  }

  static const char* value(const ::cubot::cubot_msg_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::cubot::cubot_msg_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.IMUyaw);
      stream.next(m.wheelspeed0);
      stream.next(m.wheelspeed1);
      stream.next(m.wheelspeed2);
      stream.next(m.wheelspeed3);
      stream.next(m.stm32clock);
      stream.next(m.gyrox);
      stream.next(m.gyroy);
      stream.next(m.gyroz);
      stream.next(m.accx);
      stream.next(m.accy);
      stream.next(m.accz);
      stream.next(m.qyaw);
      stream.next(m.qpitch);
      stream.next(m.qroll);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct cubot_msg_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::cubot::cubot_msg_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::cubot::cubot_msg_<ContainerAllocator>& v)
  {
    s << indent << "IMUyaw: ";
    Printer<float>::stream(s, indent + "  ", v.IMUyaw);
    s << indent << "wheelspeed0: ";
    Printer<int16_t>::stream(s, indent + "  ", v.wheelspeed0);
    s << indent << "wheelspeed1: ";
    Printer<int16_t>::stream(s, indent + "  ", v.wheelspeed1);
    s << indent << "wheelspeed2: ";
    Printer<int16_t>::stream(s, indent + "  ", v.wheelspeed2);
    s << indent << "wheelspeed3: ";
    Printer<int16_t>::stream(s, indent + "  ", v.wheelspeed3);
    s << indent << "stm32clock: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.stm32clock);
    s << indent << "gyrox: ";
    Printer<int16_t>::stream(s, indent + "  ", v.gyrox);
    s << indent << "gyroy: ";
    Printer<int16_t>::stream(s, indent + "  ", v.gyroy);
    s << indent << "gyroz: ";
    Printer<int16_t>::stream(s, indent + "  ", v.gyroz);
    s << indent << "accx: ";
    Printer<int16_t>::stream(s, indent + "  ", v.accx);
    s << indent << "accy: ";
    Printer<int16_t>::stream(s, indent + "  ", v.accy);
    s << indent << "accz: ";
    Printer<int16_t>::stream(s, indent + "  ", v.accz);
    s << indent << "qyaw: ";
    Printer<float>::stream(s, indent + "  ", v.qyaw);
    s << indent << "qpitch: ";
    Printer<float>::stream(s, indent + "  ", v.qpitch);
    s << indent << "qroll: ";
    Printer<float>::stream(s, indent + "  ", v.qroll);
  }
};

} // namespace message_operations
} // namespace ros

#endif // CUBOT_MESSAGE_CUBOT_MSG_H
